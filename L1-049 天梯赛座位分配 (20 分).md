**L1-049 天梯赛座位分配 (20 分)**

[原题链接](https://pintia.cn/problem-sets/994805046380707840/problems/994805081289900032)

作者

陈越

单位

浙江大学

代码长度限制

16 KB

时间限制

400 ms

内存限制

64 MB

---



天梯赛每年有大量参赛队员，要保证同一所学校的所有队员都不能相邻，分配座位就成为一件比较麻烦的事情。为此我们制定如下策略：假设某赛场有 N 所学校参赛，第 i 所学校有 M[i] 支队伍，每队 10 位参赛选手。令每校选手排成一列纵队，第 i+1 队的选手排在第 i 队选手之后。从第 1 所学校开始，各校的第 1 位队员顺次入座，然后是各校的第 2 位队员…… 以此类推。如果最后只剩下 1 所学校的队伍还没有分配座位，则需要安排他们的队员隔位就坐。本题就要求你编写程序，自动为各校生成队员的座位号，从 1 开始编号。

### 输入格式：

输入在一行中给出参赛的高校数 N （不超过100的正整数）；第二行给出 N 个不超过10的正整数，其中第 i 个数对应第 i 所高校的参赛队伍数，数字间以空格分隔。

### 输出格式：

从第 1 所高校的第 1 支队伍开始，顺次输出队员的座位号。每队占一行，座位号间以 1 个空格分隔，行首尾不得有多余空格。另外，每所高校的第一行按“#X”输出该校的编号X，从 1 开始。

### 输入样例：

```in
3
3 4 2
```

### 输出样例：

```out
#1
1 4 7 10 13 16 19 22 25 28
31 34 37 40 43 46 49 52 55 58
61 63 65 67 69 71 73 75 77 79
#2
2 5 8 11 14 17 20 23 26 29
32 35 38 41 44 47 50 53 56 59
62 64 66 68 70 72 74 76 78 80
82 84 86 88 90 92 94 96 98 100
#3
3 6 9 12 15 18 21 24 27 30
33 36 39 42 45 48 51 54 57 60
```

---

####  思路:

让每个学校的学生排成⼀排，为每⼀个座位安排学生。
num[i]是⼀个学校的队伍数，id_school[i]是第i个座位上坐的是哪个学校的学生。
每把椅⼦依次从每个学校⾯面前走过，如果这个学校还有学⽣没被安排座位，那就安排，安排方案为： 如果此座位前⼀个不是本校学⽣生，那么抓一个此校学生做在这把椅子上，并标记这把椅子被此校学生坐了，
如果此座位前一个是本校学生，那此位置空着，抓一个此校学生做在这把椅子的后一把上，并标记这把椅子的后一把被此校学生坐了，
设置ﬂag标志，如果所有的学校学生都被安排座位，说明安排完毕，可退出。 注意：输出时候注意⾏末不留空格

---

C++ 代码:

```c++
#include<iostream>
#include<vector>
using namespace std;

const int N = 110;

//num[i]是⼀一个学校的队伍数，id_school[i]是第i个座位上做的是哪个学校的学⽣生
int gx_num[110];//高校队数
int id_school[100010];

int main(void)
{
    int n,cnt = 1;//cnt(座位数)是id_school的下标
    cin >> n;
    vector<vector<int>> v(n+1);//预留n + 1个位置(不用第一个位置,也就是下标从1开始 当做数组用,其实这里也可以直接用数组)
    
    for(int i = 1;i <= n; i ++) cin >> gx_num[i];//i从 1 开始
    while(1)//一直遍历(因为flag在while里所以只能在while里写break来终止)
    {
        bool flag = true;
        for(int i = 1;i <= v.size() - 1; i ++)//遍历每个高校
        {
            if(v[i].size() < gx_num[i] * 10)//如果安排位置的数 小于 该高校人数
            {
                if(id_school[cnt - 1] != i)//如果第i - 1个座位坐的不是这个学校的学生
                {
                    id_school[cnt] = i;//那么就坐下来(注意到这里因为是依次的 所以只要不一样就可以直接坐下来而不需要考虑其他)
                    v[i].push_back(cnt);
                    cnt ++;
                }
                else //如果第i - 1个座位坐的是这个学校的学生
                {
                    //如果此座位前⼀个是本校学生，那此位置空着，抓⼀个此校学生坐在这把椅⼦的后一把上，并标记这把椅子的后一把被此校学生坐了，
                    id_school[cnt + 1] = i;//后一个座位被该校的学生坐了
                    v[i].push_back(cnt + 1);
                    cnt = cnt + 2;//隔开坐
                }
                flag = false;
            }
        }
        if(flag) break;
    }
    
    for(int i = 1; i <= v.size() - 1 ; i ++)//遍历每个高校
    {
        cout << '#' << i << endl;
        for(int j = 0; j < v[i].size(); j ++)//末尾空格
        {
            if(j != 0 && j % 10 != 0)cout << ' ';
            if(j != 0 && j % 10 == 0)cout << endl;
            cout << v[i][j];
        }
        cout << endl;
    }
    return 0;
    
    
}
```

